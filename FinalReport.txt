Ονόματα και ΑΜ:
 
1)Σταματούκος Θεόδωρος - 1115201400189
2)Τσινός Χρήστος - 1115201400210

Ξεκινήσαμε από την υλοποίηση του Join 2 Relations Tables όπως όριζε η Άσκηση 1 με τη χρήση του αλγορίθμου Radix Hash Join. Στη συνέχεια 
στην Άσκηση 2 ασχοληθήκαμε με το κεντρικό ζητούμενο του όλου Project, δηλαδή την μεταγλώττιση και εκτέλεση ενός ή περισσοτέρων queries
σε δεδομένα ακέραιων αριθμών. Τέλος με την Άσκηση 3 δώσαμε έμφαση στο κομμάτι του χρόνου εκτέλεσης του ολικού προγράμματός μας αναζητώντας
βέλτιστες υλοποιήσεις σε κομμάτια του κώδικα προκειμένου να επιτευχθεί αυτό.
  Πιο αναλυτικά, στο πρώτο σκέλος της εργασίας για την εκτέλεση ενός ερωτήματος σύζευξης κατά την εκτέλεση του Radix Hash Join δημιουργούσαμε 
δομές τύπου struct relation για την αναπαράσταση της κάθε σχέσης. Το κάθε relation περιελάμβανε έναν πίνακα από tuples και το πλήθος αυτών.
Το κάθε tuple περιείχε το row_id και το payload της σχέσης, όπου το row_id αποτελούσε τον αριθμό της γραμμής της σχέσης και το payload
την τιμή στον προαναφερθέντα αυτό αριθμό. Η χρήση αυτού του struct για το κάθε relation γίνεται γιατί διαχειριζόμαστε την κάθε στήλη της κάθε σχέσης και εκτελούμε joins μεταξύ των στηλών αυτών.
  Στην αντιμετώπιση των queries αρχικά τα "μεταγλωττίζαμε" από μορφή binary σε μορφή κατάλληλη για να μπορέσουμε να τα επεξεργαστούμε και τα
αποθηκεύαμε σε έναν μεγάλο πίνακα διαχωρίζοντας την κάθε σχέση και στήλη με αναγνωριστικά indexes. Στη συνέχεια, εντοπίζαμε ποιες σχέσεις μας δίνονται για επεξεργασία στο query, τι είδους επεξεργασία θα πρέπει να εκτελέσουμε μεταξύ των σχέσεων αυτών και ποια πεδία των σχέσεων αυτών
θα πρέπει να επιστρέψουμε ως τελικά αποτελέσματα. Πιο συγκεκριμένα, στο κομμάτι των πράξεων διαφοροποιούσαμε την κάθε πράξη σε 2 μεγάλες 
κατηγορίες (κατηγόρημα φίλτρου, κατηγόρημα σύζευξης). Άμα η πράξη ήταν κατηγόρημα φίλτρου μειώναμε το πλήθος των τιμών από την εκάστοτε σχέση με βάση την απαίτηση του αντίστοιχου φίλτρου, ενώ αν αποτελούσε κατηγόρημα σύζευξης εκτελούσαμε τη συνάρτηση Radix Hash Join από το πρώτο σκέλος της άσκησης. Για να συμβεί το τελευταίο "χτίζαμε" ένα struct relation με τις τιμές από την κάθε σχέση που συμμετείχε στο join και τα
2 relations που θα είχαν δημιουργηθεί στο τέλος τα περνούσαμε στη συνάρτηση Radix Hash Join που εν τέλη μας επέστρεφε την λίστα των αποτελεσμάτων. Η λίστα των αποτελεσμάτων αποτελούνταν από κόμβους που ο κάθε ένας από αυτούς περιείχε έναν buffer με tupples και το πλήθος των tupples αυτών. Κατά τη διάρκεια εκτέλεσης όλων των κατηγορημάτων τα κατηγορήματα ήταν παραπάνω από ένα, οπότε τα αποτελέσματα συνεχώς ανανεώνονταν μετά από κάθε πράξη. Προκειμένου να συγκρατούμε το κάθε ενδιάμεσο αποτέλεσμα έχουμε δημιουργήσει μία ενδιάμεση δομή η οποία 
διατηρεί μετά από κάθε πράξη τα row_ids της κάθε σχέσης που απομένουν (προκειμένου μέσω αυτών να έχουμε πρόσβαση στις τιμές τους (payloads)). Μετά το τέλος της εκτέλεσης του τελευταίου κατηγορήματος με βάση το ποιες στήλες των σχέσεων μας έχουν δοθεί για εμφάνιση εμφανίζουμε για 
την κάθε μία το check_sum, δηλαδή το άθροισμα όλων των payloads κάθε στήλης των row_ids που έχουν απομείνει για την δοθείσα σχέση.
  Στο τελικό σκέλος της εργασίας όπως προαναφέρθηκε βασιστήκαμε σε βέλτιστες μεθόδους και αλγορίθμους που θα μπορούσαμε να εισάγουμε στο
πρόγραμμά μας προκειμένου να βελτιστοποιήσουμε τον χρόνο εκτέλεσής του. Το ένα σημείο που εστιάσαμε σύμφωνα με τις οδηγίες της άσκησης είναι 
η ορθή σειρά εκτέλεσης των κατηγορημάτων κάθε query. Για το σημείο αυτό υλοποιήσαμε μία συνάρτηση που επιλέγει πάντα να εκτελεί πρώτα τα 
κατηγορήματα φίλτρου και έπειτα κατατάσσει όλα τα κατηγορήματα σύζευξης σε αύξουσα σειρά με βάση τις διακριτές τιμές της στήλης της κάθε σχέσης που συμμετέχει στο κατηγόρημα σύζευξης. Ένα ακόμα σημείο που εφιστήσαμε την προσοχή μας είναι κατά την εκτέλεση της Radix Hash Join 
να παραλληλοποιήσουμε 3 σημεία του αλγορίθμου. Το 1ο αφορά τη στιγμή δημιουργίας ιστογραμμάτων των 2 σχέσεων, το 2ο αφορά την ταξινόμηση των στοιχείων κάθε σχέσης στα κατάλληλα buckets με βάση την hash_function_1 που έχει προηγηθεί και το 3ο αφορά τη διαδικασία σύγκρισης ενός
ζευγαριού buckets και επιλογής των κατάλληλων τιμών που ταιριάζουν (Join) και σχηματισμού της τελικής λίστας των αποτελεσμάτων με τον
συνδυασμό των λιστών που έχει δημιουργήσει το κάθε thread και τη σύνθεση της τελικής λίστας με τη χρήση αυτών.


Δομές Δεδομένων που χρησιμοποιήθηκαν (οι πιο βασικές):

1)Η λίστα των αποτελεσμάτων της Readix Hash Join αποτελείται από κόμβους που περιέχουν ο καθένας από έναν buffer μεγέθους 10000 θέσεων
2)Η δομή των ενδιάμεσων αποτεσμάτων αποτελείται από μία ή και δύο σε ορισμένες περιπτώσεις μικρότερες δομές που αποθηκεύουν σε πίνακα 
τα row_ids που απομένουν σε κάθε σχέση μετά από κάθε κατηγόρημα
3)Στην δομή των tuples εκτός από το row_id και το payload συγκατούμε και ένα index στην ενδιάμεση δομή το οποίο χρησιμεύει στην ενημέρωση της
ενδιάμεσης δομής
4)Η δομή που συγκρατεί όλα τα δεδομένα των αρχείων που εισάγει ο χρήστης στο πρόγραμμα που είναι ένας πίνακας σχέσεων και των στηλών τους, που 
στον οποίο ακόμα συγκρατούμε τα χαρακτηρίστικα της κάθε στήλης κάθε σχέσης (ελάχιστη τιμή, μέγιστη τιμή, πλήθος διακριτών τιμών, πλήθος τιμών)
5)Η δομή που χρησιμοποιούμε για την παραλληλοποίηση του προγράμματός μας που αποτελεί μία ουρά από struct Jobs την διαχειρίζονται τα threads 
για την εξυπηρέτηση των Jobs που προκύπτουν (ο συγχρονισμός των threads επιτυγχάνεται με τη χρήση semaphores και mutexes).


Ενδεικτικοί χρόνοι εκτέλεσης με την παραλληλοποίση του προγράμματος μόνο στη δημιουργία ιστογραμμάτων:

3.27 secs

Ενδεικτικοί χρόνοι εκτέλεσης με την παραλληλοποίση του προγράμματος και στα 3 αναφερθέντα σημεία:

7.37 secs

Το σύστημα που εξετάσαμε το πρόγραμμα έχει 4 πυρήνες και 2 threads κάθε πυρήνας. Αυτοί οι χρόνοι είναι οι βέλτιστοι με τη χρήση 3 threads, 
bufferSize = 10000 και το ν για την hash_function_1 = 4

Τρόπος εκτέλεσης:
make clean
make
./mainP2 < small.work
grep -f mySmall.result small.result
